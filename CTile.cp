// CTile.cp#include "CTile.h"#include <sound.h>const int kTileSpeed = 8;static int RandomNum(int bound) {	UInt16 value = ::Random();	return value / 65536.0 * bound;}CTile::CTile(LStream *inStream)	: LPane(inStream) {	inStream->ReadData(&mResID, sizeof(mResID));	inStream->ReadPString(mTitle);		mSoundChannel = NULL;	OSErr err = ::SndNewChannel(&mSoundChannel, sampledSynth, 0, NULL);	// err==0 means it worked	mTall = mWinner = false;	SetRandomVelocity();}CTile::~CTile() {	::SndDisposeChannel(mSoundChannel, true);}void CTile::FinishCreateSelf() {	PicHandle picture = ::GetPicture(mResID);	Rect picFrame = (**picture).picFrame;	::ReleaseResource((Handle) picture);	ResizeFrameTo(picFrame.right - picFrame.left, picFrame.bottom - picFrame.top, false);	StartIdling();}void CTile::DrawSelf() {	Rect frame;		CalcLocalFrameRect(frame);	PicHandle picture = (mWinner ? ::GetPicture(1000) : ::GetPicture(mResID));	::DrawPicture(picture, &frame);	::ReleaseResource((Handle) picture);}void CTile::ClickSelf(const SMouseDownEvent &inMouseDown) {	Rect frame;	SDimension16 size;	CalcLocalFrameRect(frame);	GetFrameSize(size);		if (mTall = !mTall) {		ResizeFrameTo(size.width, size.height * 2, true);		MoveBy(0, - size.height / 2, true);	} else {		ResizeFrameTo(size.width, size.height / 2, true);		MoveBy(0, + size.height / 4, true);	}		Handle snd = ::Get1Resource('snd ', mResID);	::SndPlay(mSoundChannel, (SndListHandle)snd, true);		LView* view = NULL;	CTileView* tileView = NULL;  	view = GetSuperView();	tileView = (CTileView*) view;	tileView->TileWasClicked(this);}void CTile::SpendTime(const EventRecord& inMacEvent) {	UInt32 now = ::TickCount();	if (now - mTickCount < 2) return;	mTickCount = now;	if (mWinner && (now - mWinnerStart >= 60)) {		SetWinner(false);		LView* view = NULL;		CTileView* tileView = NULL;  		view = GetSuperView();		tileView = (CTileView*) view;		tileView->ChangeSpecial();	}	Rect sub, super;	CalcLocalFrameRect(sub);	mSuperView->CalcLocalFrameRect(super);	::OffsetRect(&sub, mDeltaX, mDeltaY);		if (::PtInRect(topLeft(sub), &super) && ::PtInRect(botRight(sub), &super)) {		if (mWinner) {			MoveBy(5 * mDeltaX, 5 * mDeltaY, true);		} else {			MoveBy(mDeltaX, mDeltaY, true);		}	} else {		SetRandomVelocity();	}}void CTile::UpdateCaption(LCaption* caption) {	LStr255 string(mTitle); 	// copy mTitle into string	string.Append("\p       ");	// spaces draw over old (cheezy!)	caption->SetDescriptor(string);}void CTile::SetWinner(Boolean winnerState) {	if (mWinner = winnerState) mWinnerStart = ::TickCount();	Refresh();}void CTile::SetRandomVelocity() {	mDeltaX = (RandomNum(2) * 2 - 1) * ((RandomNum(kTileSpeed + 1) + kTileSpeed) / 2);	mDeltaY = (RandomNum(2) * 2 - 1) * ((RandomNum(kTileSpeed + 1) + kTileSpeed) / 2);}